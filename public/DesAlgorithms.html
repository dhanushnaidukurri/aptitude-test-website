<html>
    <head>
        <title>Probability</title>
        <link rel="stylesheet" href="probability.css">
    </head>
    <body>
        
        <section class="s2">
            <h1>Designing Algorithms</h1>
            <nav class="s21">
                <a href="Home.html">Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
                <a href="Login.html">Login</a>&nbsp;&nbsp;&nbsp;&nbsp;
                <a href="Signup.html">Signup</a>
            </nav>
        </section>
        <section class="s1">
            <a href="Level1algo.html"><h3><strong>Level 1</strong></h3></a><br><br>
            <a href="Level2algo.html"><h3><strong>Level 2</strong></h3></a><br><br>
            
        </section>
        <div class="des1">
            <h2>Topics : - </h2>
        </div>
        <div class="des2">
            <a href="#ConditionalProbability"><strong>Sorting Algorithms</strong></a><br><br>
            <a href="#ProbabilityDistributions"><strong>Graph Algorithms</strong></a><br><br>
            <a href="#BayesianProbability"><strong>Dynamic Programming</strong></a><br><br>
            <a href="#MarkovChains"><strong>Markov Chains</strong></a><br><br>
            <a href="#RandomVariables"><strong>Random Variables</strong></a><br><br>
        </div>
        <div id="ConditionalProbability">
            <h3>Formulas on Sorting Algorithms : </h3>
            <p>
                
                <ul>
                    <li>Importance of Sorting: Sorting is a fundamental operation in computer science and is used in various applications, from searching and data retrieval to optimizing data for efficient processing.</li><br>
                    <li>Comparison-Based Sorting: Most sorting algorithms are comparison-based, where elements are compared and rearranged based on comparison results, with notable algorithms like QuickSort and MergeSort</li><br>
                    <li>Non-Comparison Sorting: Explore algorithms like Counting Sort and Radix Sort that don't rely on element comparisons, making them more efficient for certain types of data.</li><br>
                    <li>Time Complexity: Analyze the time complexity of sorting algorithms to understand their efficiency in terms of the number of operations required in the worst, average, and best-case scenarios.</li><br>
                    <li>Choosing the Right Algorithm: Learn how to select the appropriate sorting algorithm based on the characteristics of the data to be sorted and the specific requirements of the task.</li><br>
                </ul>
            </p>
        </div>
        <div id="ProbabilityDistributions">
            <h3>Formulas on Graph Algorithms:</h3>
            <p>
                <ul>
                   <li>Graph Representation: Understand various ways to represent graphs, such as adjacency matrices and adjacency lists, and their trade-offs in terms of memory and computational complexity.</li><br>
                   <li>Depth-First Search (DFS): Explore the DFS algorithm, its applications in graph traversal, and its key components like recursion and stack-based implementations.</li><br>
                   <li>Breadth-First Search (BFS): Learn about BFS, its use in shortest path algorithms, and the queue-based approach to traversing graphs.</li><br>
                   <li>Dijkstra's Algorithm: Study the Dijkstra algorithm for finding the shortest path in weighted graphs, and understand its strengths and limitations.</li><br>
                   <li>Minimum Spanning Tree: Delve into algorithms like Kruskal's and Prim's algorithms used to find the minimum spanning tree of a graph, which has applications in network design and clustering.</li><br>
                </ul>
            </p>
        </div>
        <div id="BayesianProbability">
            <h3>Formulas on Dynamic Programming: </h3>
            <p>
                <ul>
                  <li>Concept of Memoization: Understand how memoization stores previously computed results to avoid redundant calculations and improve the efficiency of recursive algorithms.</li><br>
                  <li>Overlapping Subproblems: Recognize the importance of identifying and solving overlapping subproblems in dynamic programming, which is a key concept in many dynamic programming problems</li><br>
                  <li>Bottom-Up Approach: Explore the iterative or bottom-up approach to dynamic programming, where solutions are built iteratively from smaller subproblems.</li><br>
                  <li>Fibonacci Sequence: Learn how dynamic programming can be applied to efficiently compute the nth Fibonacci number and how it compares to a naive recursive approach.</li><br>
                  <li>Longest Common Subsequence: Study the dynamic programming solution for finding the longest common subsequence between two sequences, a common problem in string comparison.</li><br>
                   
                </ul>
            </p>
        </div>
        <div id="MarkovChains">
            <h3>Greedy Algorithms</h3>
            <p>
                <ul>
                    <li>Greedy Choice Property: Understand the fundamental concept of making locally optimal choices at each step to construct a globally optimal solution in greedy algorithms.</li><br>
                    <li>Fractional Knapsack Problem: Explore the fractional knapsack problem as an example of a greedy algorithm, where items with the highest value-to-weight ratio are selected.</li><br>
                    <li>Huffman Coding: Learn about Huffman coding, a greedy algorithm used for data compression, and how it constructs variable-length codes for characters in a message.</li><br>
                    <li>Prim's Algorithm: Examine Prim's algorithm as a greedy approach for finding the minimum spanning tree in a graph, emphasizing the selection of edges with the lowest weight.</li><br>
                    <li>Dijkstra's Algorithm Revisited: Understand how Dijkstra's algorithm, while often used in the context of shortest paths, can also be seen as a greedy algorithm that explores nodes with the shortest known distance.</li><br>
                </ul>
            </p>
        </div>
        <div id="RandomVariables">
            <h3>Formulas on  Divide and Conquer Algorithms</h3>
            <p>
                <ul>
                   <li>Recursive Structure: Understand the core principle of dividing a problem into smaller subproblems, solving them independently, and combining their results in divide and conquer algorithms.</li><br>
                   <li>MergeSort: Study MergeSort as a classic divide and conquer sorting algorithm, which divides the array into two halves, sorts them, and merges them to achieve a sorted array.</li><br>
                   <li>QuickSort: Explore QuickSort, another popular divide and conquer sorting algorithm, which selects a "pivot" element and partitions the array into two subarrays.</li><br>
                </ul>
            </p>
        </div>
        <div class="quiz">
           <center><h2>After this <br> &nbsp;&nbsp;&nbsp; </h2>Click on the levels</center>
           <center><h2>Take the Quiz tests to Know your Learning Capability</h2></center>
        </div><br><br><br>
        <div class="com">
            <center><h3>One by One complete all the levels</h3> <br>   and check your results and them goes to another level</center>
        </div>
        <footer id="last">
            <h4>Thank you</h4>
        </footer>
    </body>
</html>





